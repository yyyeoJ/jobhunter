import { FeathersBaseContext } from '../commons.js';
export interface ServiceGeneratorContext extends FeathersBaseContext {
    /**
     * The chosen service name
     */
    name: string;
    /**
     * The path the service is registered on
     */
    path: string;
    /**
     * The list of subfolders this service is in
     */
    folder: string[];
    /**
     * The `camelCase` service name starting with a lowercase letter
     */
    camelName: string;
    /**
     * The `CamelCase` service name starting with an uppercase letter
     */
    upperName: string;
    /**
     * The service class name combined as `CamelCaseService`
     */
    className: string;
    /**
     * A kebab-cased (filename friendly) version of the service name
     */
    kebabName: string;
    /**
     * The actual filename (the last element of the path)
     */
    fileName: string;
    /**
     * The kebab-cased name of the path. Will be used for e.g. database names
     */
    kebabPath: string;
    /**
     * Indicates how many file paths we should go up to import other things (e.g. `../../`)
     */
    relative: string;
    /**
     * The chosen service type
     */
    type: 'knex' | 'mongodb' | 'custom';
    /**
     * Which schema definition format to use
     */
    schema: 'typebox' | 'json' | false;
    /**
     * Wether this service uses authentication
     */
    authentication: boolean;
    /**
     * Set to true if this service is for an authentication entity
     */
    isEntityService?: boolean;
    /**
     * The authentication strategies (if it is an entity service)
     */
    authStrategies: string[];
}
/**
 * Parameters the generator is called with
 */
export type ServiceGeneratorArguments = FeathersBaseContext & Partial<Pick<ServiceGeneratorContext, 'name' | 'path' | 'type' | 'authentication' | 'isEntityService' | 'schema'>>;
export declare const generate: (ctx: ServiceGeneratorArguments) => Promise<ServiceGeneratorContext>;
