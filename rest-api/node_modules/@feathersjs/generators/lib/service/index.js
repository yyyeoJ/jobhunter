import { dirname } from 'path';
import _ from 'lodash';
import { runGenerator, runGenerators, prompt } from '@featherscloud/pinion';
import { fileURLToPath } from 'url';
import chalk from 'chalk';
import { checkPreconditions, DATABASE_TYPES, fileExists, getDatabaseAdapter, initializeBaseContext } from '../commons.js';
// Set __dirname in es module
const __dirname = dirname(fileURLToPath(import.meta.url));
export const generate = (ctx) => Promise.resolve(ctx)
    .then(initializeBaseContext())
    .then(checkPreconditions())
    .then(prompt(({ name, path, type, schema, authentication, isEntityService, feathers, lib, language }) => {
    const sqlDisabled = DATABASE_TYPES.every((name) => name === 'mongodb' || name === 'other' || !fileExists(lib, `${name}.${language}`));
    const mongodbDisabled = !fileExists(lib, `mongodb.${language}`);
    return [
        {
            name: 'name',
            type: 'input',
            when: !name,
            message: 'What is the name of your service?',
            validate: (input) => {
                if (!input || input === 'authentication') {
                    return 'Invalid service name';
                }
                return true;
            }
        },
        {
            name: 'path',
            type: 'input',
            when: !path,
            message: 'Which path should the service be registered on?',
            default: (answers) => `${_.kebabCase(answers.name)}`,
            validate: (input) => {
                if (!input || input === 'authentication') {
                    return 'Invalid service path';
                }
                return true;
            }
        },
        {
            name: 'authentication',
            type: 'confirm',
            when: authentication === undefined && !isEntityService,
            message: 'Does this service require authentication?'
        },
        {
            name: 'type',
            type: 'list',
            when: !type,
            message: 'What database is the service using?',
            default: getDatabaseAdapter(feathers === null || feathers === void 0 ? void 0 : feathers.database),
            choices: [
                {
                    value: 'knex',
                    name: `SQL${sqlDisabled ? chalk.gray(' (connection not available)') : ''}`,
                    disabled: sqlDisabled
                },
                {
                    value: 'mongodb',
                    name: `MongoDB${mongodbDisabled ? chalk.gray(' (connection not available)') : ''}`,
                    disabled: mongodbDisabled
                },
                {
                    value: 'custom',
                    name: 'A custom service'
                }
            ]
        },
        {
            name: 'schema',
            type: 'list',
            when: schema === undefined,
            message: 'Which schema definition format do you want to use?',
            suffix: chalk.grey(' Schemas allow to type, validate, secure and populate data'),
            default: feathers === null || feathers === void 0 ? void 0 : feathers.schema,
            choices: (answers) => [
                {
                    value: 'typebox',
                    name: `TypeBox ${chalk.gray(' (recommended)')}`
                },
                {
                    value: 'json',
                    name: 'JSON schema'
                },
                {
                    value: false,
                    name: `No schema${answers.type !== 'custom' ? chalk.gray(' (not recommended with a database)') : ''}`
                }
            ]
        }
    ];
}))
    .then(async (ctx) => {
    const { name, path, type, authStrategies = [] } = ctx;
    const kebabName = _.kebabCase(name);
    const camelName = _.camelCase(name);
    const upperName = _.upperFirst(camelName);
    const className = `${upperName}Service`;
    const folder = path.split('/').filter((el) => el !== '');
    const relative = ['', ...folder].map(() => '..').join('/');
    const fileName = _.last(folder);
    const kebabPath = _.kebabCase(path);
    return {
        name,
        type,
        path,
        folder,
        fileName,
        upperName,
        className,
        kebabName,
        camelName,
        kebabPath,
        relative,
        authStrategies,
        ...ctx
    };
})
    .then(runGenerators(__dirname, 'templates'))
    .then(runGenerator(__dirname, 'type', ({ type }) => `${type}.tpl.js`));
//# sourceMappingURL=index.js.map