import { resolve, dirname, relative, join } from 'path';
import { mkdir, readFile, writeFile, copyFile } from 'fs/promises';
import { mapCallables, getCallable } from '../core.js';
import { promptWriteFile, overwrite, addTrace } from './helpers.js';
import { listAllFiles, merge } from '../utils.js';
const fileName = (options) => (...targets) => {
    const fn = async (ctx) => {
        const segments = (await mapCallables(targets, ctx)).flat();
        const fullPath = resolve(ctx.cwd, ...segments);
        if (options.createFolders) {
            await mkdir(dirname(fullPath), {
                recursive: true
            });
        }
        return fullPath;
    };
    fn.file = options;
    return fn;
};
export const file = fileName({ createFolders: false, prompt: 'file' });
export const toFile = fileName({ createFolders: true, prompt: 'to file' });
export const fromFile = fileName({ createFolders: false, prompt: 'from file' });
/**
 * Recursively copy all files from a folder to a destination.
 * Will prompt if the to file already exists.
 *
 * @param from The (local) folder to copy files from
 * @param to The destination to copy the files to
 * @param options File copy options (e.g. `{ force: true }`)
 * @returns The current context
 */
export const copyFiles = (from, to, options = {}) => async (ctx) => {
    const source = await getCallable(from, ctx);
    const target = await getCallable(to, ctx);
    const fileList = await listAllFiles(source);
    await Promise.all(fileList.map(async (file) => {
        const destination = join(target, relative(source, file));
        await mkdir(dirname(destination), {
            recursive: true
        });
        if (await overwrite(ctx, destination, options)) {
            await copyFile(file, destination);
        }
    }));
    return addTrace(ctx, 'copyFiles', { fileList, target, source });
};
/**
 * Load a JSON file and merge the data into the context
 *
 * @param file The name of the JSON file
 * @param converter A converter that returns the data that will be merged into the context
 * @returns The current context
 */
export const loadJSON = (file, converter = (data) => data, fallback) => async (ctx) => {
    const fileName = await getCallable(file, ctx);
    let data;
    try {
        const content = (await readFile(fileName)).toString();
        data = JSON.parse(content);
    }
    catch (error) {
        if (fallback) {
            data = await getCallable(fallback, ctx);
        }
        else {
            throw error;
        }
    }
    const converted = await converter(data, ctx);
    const result = {
        ...ctx,
        ...converted
    };
    return addTrace(result, 'loadJSON', { fileName, data });
};
/**
 * Write formatted JSON to a file
 *
 * @param json The JSON data to write
 * @param file The filename to write to
 * @returns The current context
 */
export const writeJSON = (json, file, options = {}) => async (ctx) => {
    const fileName = await getCallable(file, ctx);
    const data = await getCallable(json, ctx);
    const content = JSON.stringify(data, null, '  ');
    const result = await promptWriteFile(fileName, content, ctx, options);
    return addTrace(result, 'writeJSON', { fileName, data });
};
/**
 * Merge an existing JSON file with new data
 *
 * @param json The JSON data to add to the file
 * @param file The filename to write to
 * @returns The current context
 */
export const mergeJSON = (json, file) => async (ctx) => {
    const fileName = await getCallable(file, ctx);
    const payload = await getCallable(json, ctx);
    const existingContent = (await readFile(fileName)).toString();
    const data = merge(JSON.parse(existingContent), payload);
    const content = JSON.stringify(data, null, '  ');
    await writeFile(fileName, content);
    return addTrace(ctx, 'mergeJSON', { fileName, payload });
};
//# sourceMappingURL=fs.js.map