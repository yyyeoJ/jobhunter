/// <reference types="node" resolution-mode="require"/>
import { SpawnOptions } from 'child_process';
declare const prompt: import("inquirer").PromptModule;
export interface Logger {
    warn: (msg: string) => void;
    error: (msg: string) => void;
    log: (msg: string) => void;
    notice: (msg: string) => void;
}
export declare class BasicLogger implements Logger {
    logger: typeof console;
    previousNotice: string;
    warn(msg: string): void;
    error(msg: string): void;
    log(msg: string): void;
    notice(msg: string): void;
}
export type PinionTrace = {
    name: string;
    timestamp: number;
    info: unknown;
};
export type Configuration = {
    /**
     * The current working directory
     */
    cwd: string;
    /**
     * The logger instance, writing information to the console
     */
    logger: Logger;
    force: boolean;
    /**
     * The prompt instance, used to ask questions to the user
     */
    prompt: typeof prompt;
    /**
     * Trace messages of all executed generators
     */
    trace: PinionTrace[];
    /**
     * A function to execute a command
     *
     * @param command The command to execute
     * @param args The command arguments
     * @param options The NodeJS spawn options
     * @returns The exit code of the command
     */
    exec: (command: string, args: string[], options?: SpawnOptions) => Promise<number>;
};
export type PinionContext = {
    /**
     * The current working directory
     */
    cwd: string;
    /**
     * The command line arguments
     */
    argv: string[];
    pinion: Configuration;
};
export type ContextCallable<T, C extends PinionContext> = (ctx: C) => T | Promise<T>;
export type Callable<T, C extends PinionContext> = T | ContextCallable<T, C>;
export type Promisable<T> = T | Promise<T>;
/**
 * Returns the value for a callable which can either be a plain value or a
 * callback function that takes the context and returns the value.
 *
 * @param callable A plain value or a callback function that returns the value
 * @param context The current context object
 * @returns The final value
 */
export declare const getCallable: <T, C extends PinionContext>(callable: Callable<T, C>, context: C) => Promise<T>;
export declare const mapCallables: <X, C extends PinionContext>(callables: Callable<X, C>[], context: C) => Promise<Awaited<X>[]>;
/**
 * Returns a new Pinion configuration object.
 *
 * @param initialConfig Any customized Pinion configuration settings
 * @returns
 */
export declare const getConfig: (initialConfig?: Partial<Configuration>) => Configuration;
/**
 * Returns a new Pinion context that can be passed to a generator.
 *
 * @param initialCtx The initial context data
 * @param initialConfig The initial Pinion configuration
 * @returns The initialized Pinion context.
 */
export declare const getContext: <T extends PinionContext>(initialCtx: Partial<T>, initialConfig?: Partial<Configuration>) => T;
/**
 * Returns a Promise of the initial context
 * @param initialContext
 * @returns
 * @deprecated Use `Promise.resolve(context)` instead
 */
export declare const generator: <T extends PinionContext>(initialContext: T) => Promise<T>;
export declare const runModule: (file: string, ctx: PinionContext) => Promise<any>;
export {};
